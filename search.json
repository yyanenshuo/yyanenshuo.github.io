[{"path":"/posts/0.html","content":"字节（Byte）和位（Bit） 1 GB = 1024 MB，GB：千兆 1 MB = 1024 KB，MB：兆 1 KB = 1024 B，KB：千字节，B 是 Byte 的缩写，即字节 基本数据类型\t类型\t字节数\t位数\t取值范围boolean\t布尔型\t1\t8\ttrue &#x2F; falsechar\t字符型\t2\t16\t采用unicode编码，字符的存储范围在\\u0000\\uFFFFbyte\t整型\t1\t8\t-128127short\t整型\t2\t16\t32768~32767（2^{15}int 整型\t4\t32\t2^{31}long\t整型\t8\t64\t2^{63}float\t浮点型\t4\t32\tdouble\t浮点型\t8\t64 封装、继承多态 **封装** 一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如 继承子类拥有父类非 private 的属性和方法。子类可以拥有自己属性和方法，即子类可以对父类进行扩展。子类可以用自己的方式实现父类的方法。（以后介绍）。 多态父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。 多态机制？Java语言是如何实现多态的？ 多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 Java实现多态有三个必要条件：继承、重写、向上转型。继承：在多态中必须存在有继承关系的子类和父类。重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。向上转型：创建一个子类对象，将其当成父类对象来使用 :::infoAnimal animal &#x3D; new Cat()；Animal 是父类类型，但可以引用 Cat 这个子类类型，因为是从小范围到大范围的转换。 ::: 封装（Encapsulation） 定义：封装是面向对象编程中的一种将数据（属性）和操作数据的方法封闭在一起的技术，目的是隐藏对象的内部细节并保护对象的数据。 优点：通过封装，可以防止外部代码随意修改对象内部的数据，提高了代码的安全性和健壮性。同时，封装也提高了代码的可维护性和复用性。 示例：在Java中，我们通常通过将类的变量设置为私有（private）来隐藏它们，然后通过公共（public）方法（如getter和setter）来访问这些变量。这样，可以在方法内添加逻辑来控制如何合适地读取或修改这些变量。 继承（Inheritance） 定义：继承是一种实现代码复用的机制，允许一个类（子类）继承另一个类（父类）的属性和方法。 优点：继承支持代码复用，减少了代码冗余。它还支持多态性，其中子类可以定义特定于它们的行为，同时继承父类的功能。 示例：在 Java 中，我们可以定义一个基类 Animal，它包含所有动物共有的方法 eat()。然后，我们可以创建多个子类如 Dog 和 Cat，它们继承 Animal 并可重写 eat() 方法以表现不同动物的饮食习惯。 多态（Polymorphism） 定义：多态是面向对象编程的一个核心概念，允许我们使用父类类型的引用来调用子类类型的对象，实现接口的方法不同的具体实现。 优点：多态性增加了程序的灵活性和可扩展性。通过多态，我们可以编写能够操作父类类型但实际上运行子类特定行为的代码，这样可以减少程序的复杂度，并能适应更多的功能变化。 示例：定义一个接口 Animal，它有一个方法 makeSound()。类 Dog 和 Cat 实现了 Animal 接口，各自实现了 makeSound() 方法。在运行时，通过 Animal 的引用调用 makeSound()，根据对象的实际类型，可以调用 Dog 或 Cat 的 makeSound() 方法，展示了多态性。 接口和抽象类有什么共同点和区别？ 共同点： 都不能被实例化。 都可以包含抽象方法。 都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。区别： 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。 一个类只能继承一个类，但是可以实现多个接口。 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。 接口和抽象类的共同点： 都是用于实现多态性的机制。 都不能被实例化，只能被子类继承或实现。 都可以包含抽象方法，需要由子类提供具体的实现 接口和抽象类的区别： 语法上的区别：接口使用 interface关键字进行声明，抽象类使用 abstract关键字进行声明。 实现方式的区别：一个类可以实现多个接口，但只能继承一个抽象类。 成员变量的区别：接口中只能定义常量（即静态 final 字段），而抽象类可以定义普通成员变量。 构造函数的区别：接口没有构造函数，而抽象类可以有构造函数。 方法实现的区别：接口中的方法默认都是公共的抽象方法，不包含具体的实现代码；而抽象类可以包含抽象方法和非抽象方法，其中抽象方法没有具体的实现，而非抽象方法有具体的实现代码。 使用场景的区别：接口适用于定义一组相关的操作，强调行为的规范；抽象类适用于定义一种通用的基础结构，强调子类的共性 八种数据类型 + 4 种整数型：byte、short、int、long + 2 种浮点型：float、double + 1 种字符类型：char + 1 种布尔型：boolean 对应的**包装类**分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean 属于对象； 包装和基本类型的区别： 默认值：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。比较方式：对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。对于包装数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部用 equals() 方法； 拆箱装箱 + 装箱：将基本类型用它们对应的引用类型包装起来； + 拆箱：将包装类型转换为基本数据类型； + Integer i = 10 等价于 Integer i = Integer.valueOf(10) + int n = i 等价于 int n = i.intValue(); 基本数据类型和包装类的用处 1. 一般包装类用到POJO中（POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO 等），而基本类型不行； 因为数据库的查询结果可能是null，如果使用基本类型的话，因为要自动拆箱（将包装类型转为基本类型，比如说把Integer 对象转换成int值），就会抛出 NullPointerException 的异常。 2. 包装类型可用于泛型，而基本类型不可以；泛型不能使用基本类型，因为使用基本类型时会编译出错。 12List&lt;int&gt; list = new ArrayList&lt;&gt;(); // 提示 Syntax error, insert &quot;Dimensions&quot; to complete ReferenceTypeList&lt;Integer&gt; list = new ArrayList&lt;&gt;() 基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。相比较于基本类型而言，包装类型需要占用更多的内存空间（堆中占一块内存，栈中也占用一块内存）。假如没有基本类型的话，对于数值这类经常使用到的数据来说，每次都要通过new一个包装类型就显得非常笨重。 静态方法为什么不能调用非静态成员？ 静态方法外部调用时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式 但是非静态 实例方法 只能 对象.方法名 也就是静态方法不用创建对象； 原因如下： 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。 方法的修饰符？区别？ public Protected private abstract static native final sync区别是 权限问题 String相关问题： **String str=“i“与 String str=new String(“i”)一样吗？** 不一样，区别在于 内存分配方式不一样；第一种方式，Java 虚拟机会将其分配到常量池中；第二种则会被分到堆内存中。 因为：str&#x3D;“i“ 会把i值存在常量池，地址赋给str1。假设再写一个String str2&#x3D;“i”，则会把i的地址赋给str2，但是i对象不会重新创建，他们引用的是同一个地址值，共享同一个i内存String str&#x3D;new String(“i”)；会创建一个新的i对象，然后将新对象的地址值赋给str3。虽然str3和str1的值相同但是地址值不同。 **String、StringBuffer、StringBuilder之间的区别** String 是 被声明成为 final class，所有属性也都是 final 的。是不可变的，也由于它**的不可变**性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。**用到的最多** StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。 StringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分（方法加了 sync 关键字），有效减小了开销，是绝大部分情况下进行字符串拼接的首选。大量字符串拼接时常用的。 请总结⼀下使⽤场景 String：适⽤于字符串内容不会改变的场景，⽐如说作为 HashMap 的 key。 StringBuilder：适⽤于单线程环境下需要频繁修改字符串内容的场景，⽐如在循环中拼接或修改字符串，是String 的完美替代品。 StringBuffer：现在已经不怎么⽤了，因为⼀般不会在多线程场景下去频繁的修改字符串内容 **String str = new String(\"abc\")过程** 使用构造函数构建String对象，如String str = new String(\"abc\")：通过new关键字创建字符串对象，会**先检查字符串常量池中是否有**相同的字符串，如果**有 则拷贝一份放到堆中**，然后**返回堆中地址**；如果没有 就先在字符串常量池中**创建\"abc\"这个字符串**，而后再复制一份放到堆中 并把堆地址返回给str **String str = \"abc\"过程** 使用字符串字面值创建String对象，如String str = \"abc\"：java中有个字符串常量池，当创建一个字面量字符串时，JVM首**先检查字符串常量池中是否已经存在该字符串**，如果存在 则直接**返回字符串对象的引用**，否则就**创建一个新的字符串对象并放入字符串常量池中，**最终将该**对象的引用赋值给变量str**。引用str指向常量池中字符串\"abc\"的地址，是在常量池中拿值；字符串常量池中不会存储相同内容的字符串 所以String str1&#x3D;”abc”和String str2&#x3D;new String(“abc”)区别就是：创建的对象数量不同 List和数组直接如何互相转换? list-> 数组 1. for 循环 2. toArray()方法 1234//要转换的list集合List&lt;String&gt; testList = new ArrayList&lt;String&gt;() &#123;&#123;add(&quot;aa&quot;);add(&quot;bb&quot;);add(&quot;cc&quot;);&#125;&#125;;//使用toArray(T[] a)方法String[] array2 = testList.toArray(new String[testList.size()]); 数组 -> list 1. for循环 2. asList() 12ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(arrays));List&lt;String&gt; list = Arrays.asList(arrays); // 不推荐使用 stream方法 翻转字符串 StringBuilder 自带的 revers 方法 tocharArray 方法 + for 循环倒序输出 栈 JAVA 反射 Java的 反射机制 是在运行状态中，对于任意一个类，都能够 知道这个类的所有属性和方法 ；对于任意一个对象，都能够 调用它的任意一个方法和属性 ；这种 动态获取的信息以及动态调用对象的方法的功能 称为 Java 语言的反射机制。 反射允许 Java 在运⾏时检查和操作类的⽅法和字段。通过反射，可以动态地获取类的字段、⽅法、构造⽅法等信息，并在运⾏时调⽤⽅法或访问字段。 反射的关键实现方法有以下几个： 1. 得到类：Class.forName(\"类名\") 2. 得到所有字段：getDeclaredFields() 3. 得到所有方法：getDeclaredMethods() 4. 得到构造方法：getDeclaredConstructor() 5. 得到实例：newInstance() 6. 调用方法：invoke() 实例化方法（五种）： 1、用new语句创建对象 2、使用Class类的newInstance方法 3、使用Constructor类的newInstance方法（运用反射手段） 4、调用对象的clone()方法 5、使用反序列化 其中 反射创建 用 Class 对象的 newInstance 方法。 用 Constructor 对象的 newInstance 方法 12345678910111213141516171819public class NewInstanceDemo &#123; public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; Class&lt;?&gt; c1 = StringBuilder.class; StringBuilder sb = (StringBuilder) c1.newInstance(); // `newInstance` sb.append(&quot;aaa&quot;); System.out.println(sb.toString()); //获取String所对应的Class对象 Class&lt;?&gt; c2 = String.class; //获取String类带一个String参数的构造器 Constructor constructor = c2.getConstructor(String.class); // `Constructor`对象方法 //根据构造器创建实例 String str2 = (String) constructor.newInstance(&quot;bbb&quot;); System.out.println(str2); &#125;&#125; 引用类型有哪些？有什么区别？ 引用类型主要分为强软弱虚四种： **强引用 **指的就是代码中普遍存在的赋值方式，使⽤ new 关键字赋值的引⽤就是强引⽤ 12// str 就是⼀个强引⽤ String str = new String(&quot;沉默王⼆&quot;); 只要强引⽤关联着对象，垃圾收集器就不会回收这部分对象，即使内存不⾜。 软引用 通过 SoftReference 类实现。软引⽤的对象在内存不⾜时会被回收。 12// softRef 就是⼀个软引⽤SoftReference&lt;String&gt; softRef = new SoftReference&lt;&gt;(new String(&quot;沉默王⼆&quot;)); 指的是那些有用但是不是必须要的对象。系统在发生内存溢出前会对这类引用的对象进行回收。 弱引用可以用 **WeakReference **来描述，他的强度比软引用更低一点，弱引用的对象下一次GC的时候一定会被回收，而不管内存是否足够。 1234567891011static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; //节点类 Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; //key赋值 super(k); //value赋值 value = v; &#125;&#125; 虚引用也被称作幻影引用，是最弱的引用关系，可以用 PhantomReference 来描述，他必须和ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。 深拷贝和浅拷贝 **浅拷贝**是指我们拷贝出来的对象内部的引用类型变量和原来**对象内部引用类型变量是同一引用**（指向同一对象）， 但是我们拷贝出来的对象和新对象不是同一对象; 新（拷贝产生）、旧（元对象）对象不同，但是内部如果有引用类型的变量，新、旧对象引用的都是同一引用 **深拷贝**: 全部拷贝原对象的内容，包括内存的引用类型也进行拷贝 浅拷⻉会创建⼀个新对象，但这个新对象的属性（字段）和原对象的属性完全相同。如果属性是基本数据类型，拷⻉的是基本数据类型的值；如果属性是引⽤类型，拷⻉的是引⽤地址，因此新旧对象共享同⼀个引⽤对象。 clone 方法默认是浅拷贝 clone 方法**默认是浅拷贝**的，即返回一个新的对象，但是新对象里的引用类型变量地址指向的还是原对象内引用类型地址 浅拷贝通常通过 `Object`** 类中的 **`clone()`** 方法** 实现。默认的 `clone()` 方法会进行浅拷贝。 clone()方法的深拷贝 需要手动覆盖 `clone()` 方法，确保对引用类型进行递归拷贝。 12345678910111213141516171819202122232425262728293031323334class Person implements Cloneable &#123; String name; int age; Address address; // 引用类型 public Person(String name, int age, Address address) &#123; this.name = name; this.age = age; this.address = address; &#125; // 覆盖 clone() 方法实现深拷贝 @Override protected Object clone() throws CloneNotSupportedException &#123; // 首先浅拷贝基本字段 Person clonedPerson = (Person) super.clone(); // 递归拷贝引用类型的字段 clonedPerson.address = (Address) this.address.clone(); return clonedPerson; // 返回完全独立的副本 &#125;&#125;class Address implements Cloneable &#123; String city; public Address(String city) &#123; this.city = city; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); // Address 的浅拷贝 &#125;&#125; JDK 17的主要新特性 + 模式匹配：引入了模式匹配特性，简化了代码编写。 + 密封类：增强了类型安全，限制了继承范围。 + 异常处理：改进了异常处理机制，使得错误处理更加灵活。 + I/O特性：引入了新的文件系统API和管道API，增强了I/O操作。 + 强封装：限制了内部API的可见性，提高了模块化程度。 + 外部函数和内存API：提升了与本地代码的互操作性，增强了性能。 + 垃圾收集器改进：对G1和ZGC垃圾收集器进行了优化 JDK 8 新特性 Future是什么 用于异步结果的获取; Future 代表的是异步执行的结果，意思是当异步执行结束之后，返回的结果将会保存在 Future 中。 callabel 比 runnable 多了个返回值; 并且`Callable`接口是一个泛型接口，可以**返回指定类型的结果。** 之后 `ExecutorService.submit()`方法，可以看到，它返回了一个`Future`类型，一个`Future`类型的实例代表一个未来能获取结果的对象: 1234567ExecutorService executor = Executors.newFixedThreadPool(4); // 定义任务:Callable&lt;String&gt; task = new Task();// 提交任务并获得Future:Future&lt;String&gt; future = executor.submit(task);// 从Future获取异步执行返回的结果:String result = future.get(); // 可能阻塞 当我们提交一个Callable任务后，我们会同时获得一个Future对象，然后，我们在主线程某个时刻调用Future对象的get()方法，就可以获得异步执行的结果。在调用get()时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么get()会阻塞，直到任务完成后才返回结果。 Callable + ExecutorService.submit() -&gt; Future Java8的CompletableFuture 问题: 使用`Future`获得异步执行结果时，要么调用阻塞方法`get()`，要么轮询看`isDone()`是否为`true`，这两种方法都不是很好，因为主线程也会被迫等待。 java8新引入的工具, 是对Future的扩展和增强。提供了更细致的操控;组织不同任务的运行顺序、规则以及方式(CountDownLatch也可以) CompletableFuture可以指定异步处理流程： thenAccept()处理正常结果； exceptional()处理异常结果； thenApplyAsync()用于串行化另一个CompletableFuture； anyOf()和allOf()用于并行化多个CompletableFuture。 如何使用CompletableFuture实现调用一个接口，过一段时间没完成就超时返回，中断执行任务的线程这个功能？ java8中没有 CompletableFuture 并没有 timeout 机制; 可以在在 get 的时候指定 timeout java9 引入了 `orTimeout` 和 `completeOnTimeOut` 两个方法支持 异步 timeout 机制 orTimeout: 在指定的超时时间过去后，使用TimeoutException完成CompletableFuture。completeOnTimeOut:在CompletableFuture管道超时的情况下返回一个指定的默认值。 使用例子 1234567891011121314151617181920212223242526272829303132333435363738394041public class OrTimeoutMethodTest &#123; public static void main(String args[]) throws InterruptedException &#123; int a = 10; int b = 15; CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch(InterruptedException e) &#123; e.printStackTrace(); &#125; return a + b; &#125;) .orTimeout(4, TimeUnit.SECONDS) .whenComplete((result, exception) -&gt; &#123; System.out.println(result); if(exception != null) exception.printStackTrace(); &#125;); TimeUnit.SECONDS.sleep(10); &#125;&#125;public class CompleteOnTimeOutMethodTest &#123; public static void main(String args[]) throws InterruptedException &#123; int a = 10; int b = 15; CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch(InterruptedException e) &#123; e.printStackTrace(); &#125; return a + b; &#125;) .completeOnTimeout(0, 4, TimeUnit.SECONDS) .thenAccept(result -&gt; System.out.println(result)); TimeUnit.SECONDS.sleep(10); &#125;&#125; java异常处理 ![](https://cdn.nlark.com/yuque/0/2024/png/42573811/1734607922116-685f8f57-ade4-456c-8538-80edf49d02f0.png) Exception、Error 和 Throwable **Throwable** 是异常和错误的超类，有两个**子类 Exception 和 Error** Exception（异常）：Java异常分为两种类型：（编译时异常、运行时异常） 编译时异常：是指在编译时强制检查的异常，必须在代码中显式地处理或声明抛出。例如，IOException和SQLException就是已检查异常。 如果⽅法可能抛出某种编译时异常，但没有捕获它（try-catch）或没有在⽅法声明中⽤ throws ⼦句声明它，那么编译将不会通过。例如：IOException、SQLException 等。 运行时异常：是指在编译时不强制检查的异常，不需要在代码中显式地处理或声明抛出。这类异常在运⾏时抛出，它们都是 RuntimeException 的⼦类。对于运⾏时异常，Java 编译器不要求必须处理它们（即不需要捕获也不需要声明抛出） 常见的未检查异常包括NullPointerException、ArrayIndexOutOfBoundsException和 ArithmeticException等。 Error（错误）：Error也是 Java 中的一个类，表示通常超出程序控制范围的严重问题。错误通常是由外部因素或JVM或系统的基本问题引起的。错误的例子包括 OutOfMemoryError 和 StackOverflowError。与异常不同，错误通常不应该被程序捕获和处理，因为它们表示严重的问题，可能是无法恢复的。 常见 Exception、 Error **Exception：** 🌴 NullPointerException（空指针异常）：当尝试使用空引用调用对象的方法或访问对象的字段时抛出。 🌴 ArrayIndexOutOfBoundsException（数组越界异常）：当尝试访问数组中不存在的索引时抛出。 🌴 IllegalArgumentException（非法参数异常）：当传递给方法的参数不满足方法的要求时抛出。 🌴 IllegalStateException（非法状态异常）：当对象的状态不符合方法调用的前提条件时抛出。 🌴 IOException（输入输出异常）：在处理输入输出操作时发生错误时抛出。 🌴 ClassNotFoundException（类未找到异常）：当尝试加载不存在的类时抛出。 🌴 InterruptedException（中断异常）：在线程等待、休眠或阻塞的过程中被中断时抛出。 🌴 SQLException（SQL异常）：在访问数据库时发生错误时抛出。 🌴 FileNotFoundException（文件未找到异常）：当尝试访问不存在的文件时抛出。 🌴 ArithmeticException（算术异常）：在算术操作中出现错误时抛出，例如除以零。 Error：🌴 OutOfMemoryError（内存溢出错误）：当Java虚拟机无法为对象分配足够的内存空间时抛出。🌴 StackOverflowError（栈溢出错误）：当方法调用的调用栈超过其限制时抛出，通常是由于递归调用导致的。🌴 NoClassDefFoundError（类未定义错误）：当Java虚拟机无法找到类的定义时抛出，通常是由于类路径配置错误或类文件缺失引起的。🌴 LinkageError（链接错误）：当Java虚拟机在类加载过程中遇到链接错误时抛出，例如类与其依赖的类不兼容。🌴 AssertionError（断言错误）：当断言语句失败时抛出，通常用于在代码中检查预期的条件是否满足。🌴 VirtualMachineError（虚拟机错误）：表示Java虚拟机内部发生了错误，例如栈溢出、垃圾回收失败等。🌴 InternalError（内部错误）：表示Java虚拟机内部发生了严重的错误，无法恢复。 try-catch-final try-catch-final哪些可以省略 以下三种情况都是可以的： try-catch try-finally try-catch-finally 可以省略catch或者finally，catch和finally不可以同时省略。 finally是必须的吗，什么时候加上 finally并不是必须的，finally里一般拿来做一些善后清理工作 try块里出现错误的话，会立即跳出try块，找到匹配的错误，执行catch块里的语句 此时，可能在try块里打开的文件没关闭，连接的网络没断开，对这些浪费的内存就不能及时释放回收。 如果有finally块的话，不管有没有出错，都会执行finally块里的内容。 如果 catch 中 return 了，finally 还会执行吗？ **会** finally的作用就是，无论出现什么状况，finally里的代码一定会被执行。 如果在catch中return了，也会在return之前，先执行finally代码块。 而且如果finally代码块中含有return语句，会覆盖其他地方的return。 对于基本数据类型的数据，在finally块中改变return的值对返回值没有影响，而对引用数据类型的数据会有影响。 注：finally也不是一定会被执行。 什么情形下，finally代码块不会执行？ 1. 没有进入try代码块； 2. System.exit()强制退出程序； 3. 守护线程被终止； 初始化Bean的方法 1. spring加载配置 Bean 2. 实现 initializingBean 接口的afterPropertiesSet()方法（InitializingBean 为实现该接口**的bean提供默认的初始化方法**） 3. postProcessAfterInitialization()方法里实现自定义Bean（BeanPostProcessor 为每个**bean实例化时提供个性化的修改，做些包装等**） 动态代理怎么实现？ JDK 动态代理的实现 通过JDK提供的一个`Proxy.newProxyInstance()`创建代理对象； 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;// 代理的行为public interface ExecutorInterface &#123; void execute(int x, int y);&#125;// 被代理的对象public class Executor implements ExecutorInterface &#123; public void execute(int x, int y) &#123; if (x == 3) &#123; return; &#125; for (int i = 0; i &lt; 100; i++) &#123; if (y == 5) &#123; return; &#125; &#125; return; &#125;&#125;// handlerpublic class TimeLogHandler implements InvocationHandler &#123; private Object target; public TimeLogHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; log.info(&quot;start：&#123;&#125;&quot;, System.nanoTime()); Object result = method.invoke(target, args); log.info(&quot;end：&#123;&#125;&quot;, System.nanoTime()); return result; &#125;&#125;// 生成代理类Executor executor = (Executor) Proxy.newProxyInstance( Executor.class.getClassLoader(), new Class[]&#123;Executor.class&#125;, new TimeLogHandler); Spring 里的动态代理实现 提供的 ProxyFactory 有一个 getProxy() 方法，实现ProxyFactory接口重写 getProxy() 方法； 1234567891011121314151617181920212223242526272829303132public class JDKProxyFactory implements ProxyFactory &#123; @Override public &lt;T&gt; T getProxy(ReferenceWrapper&lt;T&gt; referenceWrapper) throws Throwable &#123; return (T) Proxy.newProxyInstance(referenceWrapper.getAimClass().getClassLoader(), new Class&lt;?&gt;[]&#123;referenceWrapper.getAimClass()&#125;, new JDKClientInvocationHandler(referenceWrapper)); &#125; &#125;// Proxy.newProxyInstance是JDK静态方法，参数三个：// ClassLoader loader, // Class&lt;?&gt;[] interfaces, // InvocationHandler h其中，new JDKClientInvocationHandler(referenceWrapper)的JDKClientInvocationHandler类实现了InvocationHandler类，重写invoke()方法，在该方法里做代理相关的处理。// 使用public class RpcReference &#123; public ProxyFactory proxyFactory; public RpcReference(ProxyFactory proxyFactory) &#123; this.proxyFactory = proxyFactory; &#125; /** * 根据接口类型获取代理对象 */ public &lt;T&gt; T get(ReferenceWrapper&lt;T&gt; referenceWrapper) throws Throwable&#123; return proxyFactory.getProxy(referenceWrapper); &#125; &#125;根据类型自动获取一个对象 原理 使用流程 创建 InvocationHandler 实现：定义一个 InvocationHandler 的实现，这个实现中的 invoke 方法可以包含自定义逻辑。 创建代理对象：使用 Proxy.newProxyInstance 方法，传入目标对象的类加载器、需要代理的接口数组以及 InvocationHandler 的实现，来创建一个实现了指定接口的代理对象。 InvocationHandler 是动态代理的核心接口之一，当我们使用动态代理模式创建代理对象时，任何对代理对象的方法调用都会被转发到一个实现了 InvocationHandler 接口的实例的 invoke 方法上。 我们经常看到InvocationHandler 动态代理的匿名内部类，这会在代理对象的相应方法被调用时执行。具体地说，每当对代理对象执行方法调用时，调用的方法不会直接执行，而是转发到实现了InvocationHandler** 的 invoke 方法上。在这个 invoke 方法内部，我们可以定义拦截逻辑、调用原始对象的方法、修改返回值等操作**。 静态代理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 定义行为 */public interface Marry &#123; public void toMarry();&#125;/** * 静态代理 ——&gt; 目标对象 */public class You implements Marry &#123; // 实现行为 @Override public void toMarry() &#123; System.out.println(&quot;我要结婚了...&quot;); &#125;&#125;/** * 静态代理 ——&gt; 代理对象 */public class MarryCompanyProxy implements Marry &#123;​ // 目标对象 private Marry marry; // 通过构造器将目标对象传入 public MarryCompanyProxy(Marry marry) &#123; this.marry = marry; &#125;​ // 实现行为 @Override public void toMarry() &#123; // 增强行为 before(); // 执行目标对象中的方法 marry.toMarry(); // 增强行为 after(); &#125;​ /** * 增强行为 */ private void after() &#123; System.out.println(&quot;新婚快乐，早生贵子！&quot;); &#125;​ /** * 增强行为 */ private void before() &#123; System.out.println(&quot;场地正在布置中...&quot;); &#125;&#125;使用：// 目标对象You you = new You();// 构造代理角色同时传入真实角色MarryCompanyProxy marryCompanyProxy = new MarryCompanyProxy(you);// 通过代理对象调用目标对象中的方法marryCompanyProxy.toMarry(); 零拷贝 零拷贝技术实现的方式通常有 2 种： mmap + write sendfile 主要是为了减少 内核缓冲区的数据拷贝到用户的缓冲区 这样的切换用户&#x2F;内核态mmap() 直接把内核缓冲区里的数据「映射」到用户空间，减少一次切换。 Kafka 这个开源项目，就利用了「零拷贝」技术，从而大幅提升了 I&#x2F;O 的吞吐率，这也是 Kafka 在处理海量数据为什么这么快的原因之一。如果你追溯 Kafka 文件传输的代码，你会发现，最终它调用了 Java NIO 库里的 transferTo方法 项目有遇到过循环依赖吗？如何解决 主要就是 重构代码； 平移 A和B互相依赖，那么可以将B依赖A的那部分代码，移动到工程B中，这样一来，B就不需要继续依赖A，只要A依赖B就可以了，从而消除循环依赖 下移，比如A和B互相依赖，同时它们都依赖C，那么可以将B和A相互依赖的那部分代码，移动到工程C里，这样一来，A和B相互之间都不依赖，只继续依赖C，也可以消除循环依赖 java读文件 1.Mmap映射文件到内存，之后写入，刷盘 2.java.io.FileInputStream和java.io.FileOutputStream 方式 123FileInputStream fis = new FileInputStream(&quot;abc.txt&quot;); byte[] data = new byte[100]; int len = fis.read(data); 123FileOutputStream fos = new FileOutputStream(&quot;abc.txt&quot;,true); ​ fos.write(&quot;???&quot;.getBytes());"},{"title":"test1","path":"/posts/undefined.html","content":"source_posts\\test1\\JavaTBB.jpg","tags":["iOS","心率"],"categories":["设计开发","iOS开发"]},{"title":"Hello World","path":"/posts/16107.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]