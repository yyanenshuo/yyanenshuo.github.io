
<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.29.1" theme-name="Stellar" theme-version="1.29.1">
  
  <meta name="generator" content="Hexo 7.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>Yes的知识星球</title>

  
    <meta name="description" content="字节（Byte）和位（Bit） 1 GB &#x3D; 1024 MB，GB：千兆   1 MB &#x3D; 1024 KB，MB：兆   1 KB &#x3D; 1024 B，KB：千字节，B 是 Byte 的缩写，即字节  基本数据类型	类型	字节数	位数	取值范围boolean	布尔型	1	8	true &#x2F; falsechar	字符型	2	16	采用unicode编码，字符的存储范围在\u0000\uFFFF">
<meta property="og:type" content="article">
<meta property="og:title" content="Yes的知识星球">
<meta property="og:url" content="http://example.com/posts/0.html">
<meta property="og:site_name" content="Yes的知识星球">
<meta property="og:description" content="字节（Byte）和位（Bit） 1 GB &#x3D; 1024 MB，GB：千兆   1 MB &#x3D; 1024 KB，MB：兆   1 KB &#x3D; 1024 B，KB：千字节，B 是 Byte 的缩写，即字节  基本数据类型	类型	字节数	位数	取值范围boolean	布尔型	1	8	true &#x2F; falsechar	字符型	2	16	采用unicode编码，字符的存储范围在\u0000\uFFFF">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2025/png/42573811/1735979115349-58a155ab-401d-4141-8c0b-5bb700dec0eb.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2025/png/42573811/1735978408986-70d87a41-71f7-452f-91d0-b72e97fcffc8.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42573811/1734608227487-e7150ca7-3ea0-40ba-8b26-e8de4e3e38dc.png">
<meta property="article:published_time" content="2025-01-27T07:26:11.579Z">
<meta property="article:modified_time" content="2025-01-27T07:26:43.318Z">
<meta property="article:author" content="啊呦硕">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2025/png/42573811/1735979115349-58a155ab-401d-4141-8c0b-5bb700dec0eb.png">
  
  
  
  

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.29.1">

  
    <link rel="shortcut icon" href="/images/icon.svg">
  

  

  <link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'">
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/images/icon.svg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Yes的知识星球</div><div class="sub normal cap">探索未知，记录心得</div><div class="sub hover cap" style="opacity:0"> Explore the unknown, record the insights</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="Search"></form><div id="search-result"></div><div class="search-no-result">No Results!</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">Recent Update</span></div><div class="widget-body fs14"><a class="item title" href="/posts/undefined.html"><span class="title"><strong>test</strong><span class="dot"></span>test1</span></a><a class="item title" href="/posts/16107.html"><span class="title">Hello World</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/yyanenshuo" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.svgrepo.com/show/512317/github-142.svg"/></a><a class="social" href="https://space.bilibili.com/395377981?spm_id_from=333.1387.0.0" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://pic.eryinote.com/PicGo/202403292128856.svg"/></a><a class="social" href="/comments/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.svgrepo.com/show/535318/comments.svg"/></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a></div>
<div class="flex-row" id="post-meta"><span class="text created">Posted on: <time datetime="2025-01-27T07:26:11.579Z">2025-01-27</time></span><span class="sep updated"></span><span class="text updated">Updated on: <time datetime="2025-01-27T07:26:43.318Z">2025-01-27</time></span></div></div></div>
    
  </div>
  </div><article class="md-text content"><h3 id="VDtbV">字节（Byte）和位（Bit）</h3>
1 GB = 1024 MB，GB：千兆  
1 MB = 1024 KB，MB：兆  
1 KB = 1024 B，KB：千字节，B 是 Byte 的缩写，即字节

<p>基本数据类型	类型	字节数	位数	取值范围<br>boolean	布尔型	1	8	true &#x2F; false<br>char	字符型	2	16	采用unicode编码，字符的存储范围在\u0000<del>\uFFFF<br>byte	整型	1	8	-128</del>127<br>short	整型	2	16	32768~32767（2^{15}<br>int	    整型	4	32	2^{31}<br>long	整型	8	64	2^{63}<br>float	浮点型	4	32	<br>double	浮点型	8	64	</p>
<h3 id="rAglo">封装、继承多态</h3>
**封装**  
一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如

<p><strong>继承</strong><br>子类拥有父类非 private 的属性和方法。<br>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>子类可以用自己的方式实现父类的方法。（以后介绍）。</p>
<p><strong>多态</strong><br>父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</p>
<h4 id="Q2qrV">多态机制？Java语言是如何实现多态的？</h4>
多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

<p>Java<strong>实现多态有三个必要条件：继承、重写、向上转型</strong>。<br>继承：在多态中必须存在有继承关系的子类和父类。<br>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。<br>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。<br>向上转型：创建一个子类对象，将其当成父类对象来使用</p>
<p>:::info<br>Animal   animal  &#x3D;  new Cat()；<br>Animal 是父类类型，但可以引用 Cat 这个子类类型，因为是从小范围到大范围的转换。</p>
<p>:::</p>
<p><strong>封装</strong>（Encapsulation）</p>
<ul>
<li>定义：封装是面向对象编程中的一种将数据（属性）和操作数据的方法封闭在一起的技术，目的是隐藏对象的内部细节并保护对象的数据。</li>
<li>优点：通过封装，可以防止外部代码随意修改对象内部的数据，提高了代码的安全性和健壮性。同时，封装也提高了代码的可维护性和复用性。</li>
<li>示例：在Java中，我们通常通过将类的变量设置为私有（private）来隐藏它们，然后通过公共（public）方法（如getter和setter）来访问这些变量。这样，可以在方法内添加逻辑来控制如何合适地读取或修改这些变量。</li>
</ul>
<p><strong>继承</strong>（Inheritance）</p>
<ul>
<li>定义：继承是一种实现代码复用的机制，允许一个类（子类）继承另一个类（父类）的属性和方法。</li>
<li>优点：继承支持代码复用，减少了代码冗余。它还支持多态性，其中子类可以定义特定于它们的行为，同时继承父类的功能。</li>
<li>示例：在 Java 中，我们可以定义一个基类 Animal，它包含所有动物共有的方法 eat()。然后，我们可以创建多个子类如 Dog 和 Cat，它们继承 Animal 并可重写 eat() 方法以表现不同动物的饮食习惯。</li>
</ul>
<p><strong>多态</strong>（Polymorphism）</p>
<ul>
<li>定义：多态是面向对象编程的一个核心概念，允许我们使用父类类型的引用来调用子类类型的对象，实现接口的方法不同的具体实现。</li>
<li>优点：多态性增加了程序的灵活性和可扩展性。通过多态，我们可以编写能够操作父类类型但实际上运行子类特定行为的代码，这样可以减少程序的复杂度，并能适应更多的功能变化。</li>
<li>示例：定义一个接口 Animal，它有一个方法 makeSound()。类 Dog 和 Cat 实现了 Animal 接口，各自实现了 makeSound() 方法。在运行时，通过 Animal 的引用调用 makeSound()，根据对象的实际类型，可以调用 Dog 或 Cat 的 makeSound() 方法，展示了多态性。</li>
</ul>
<h3 id="IGWIF">接口和抽象类有什么共同点和区别？</h3>
共同点：

<ul>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。<br>区别：</li>
<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li>
</ul>
<p><strong>接口和抽象类的共同点</strong>：</p>
<ol>
<li>都是用于实现多态性的机制。</li>
<li>都不能被实例化，只能被子类继承或实现。</li>
<li>都可以包含抽象方法，需要由子类提供具体的实现</li>
</ol>
<p><strong>接口和抽象类的区别：</strong></p>
<ol>
<li>语法上的区别：接口使用 interface关键字进行声明，抽象类使用 abstract关键字进行声明。</li>
<li>实现方式的区别：一个类可以实现多个接口，但只能继承一个抽象类。</li>
<li>成员变量的区别：接口中只能定义常量（即静态 final 字段），而抽象类可以定义普通成员变量。</li>
<li>构造函数的区别：接口没有构造函数，而抽象类可以有构造函数。</li>
<li>方法实现的区别：接口中的方法默认都是公共的抽象方法，不包含具体的实现代码；而抽象类可以包含抽象方法和非抽象方法，其中抽象方法没有具体的实现，而非抽象方法有具体的实现代码。</li>
<li>使用场景的区别：接口适用于定义一组相关的操作，强调行为的规范；抽象类适用于定义一种通用的基础结构，强调子类的共性</li>
</ol>
<h3 id="jLKie">八种数据类型</h3>
+ 4 种整数型：byte、short、int、long
+ 2 种浮点型：float、double
+ 1 种字符类型：char
+ 1 种布尔型：boolean   
对应的**包装类**分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean 属于对象；



<p>包装和基本类型的区别：</p>
<p><strong>默认值</strong>：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。<br><strong>比较方式</strong>：对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。对于包装数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部用 equals() 方法；</p>
<h4 id="yqMUe">拆箱装箱</h4>
+ 装箱：将基本类型用它们对应的引用类型包装起来；
+ 拆箱：将包装类型转换为基本数据类型；
+ Integer i = 10 等价于 Integer i = Integer.valueOf(10)
+ int n = i 等价于 int n = i.intValue();

<h3 id="iWeBu">基本数据类型和包装类的用处</h3>
1. 一般包装类用到POJO中（POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO 等），而基本类型不行；  
因为数据库的查询结果可能是null，如果使用基本类型的话，因为要自动拆箱（将包装类型转为基本类型，比如说把Integer 对象转换成int值），就会抛出 NullPointerException 的异常。
2. 包装类型可用于泛型，而基本类型不可以；泛型不能使用基本类型，因为使用基本类型时会编译出错。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="type">int</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 提示 Syntax error, insert &quot;Dimensions&quot; to complete ReferenceType</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。<br>相比较于基本类型而言，包装类型需要占用更多的内存空间（堆中占一块内存，栈中也占用一块内存）。假如没有基本类型的话，对于数值这类经常使用到的数据来说，每次都要通过new一个包装类型就显得非常笨重。</li>
</ol>
<h3 id="zKJHw">静态方法为什么不能调用非静态成员？</h3>
静态方法外部调用时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式  
但是非静态 实例方法 只能 对象.方法名 也就是静态方法不用创建对象；  
原因如下：

<ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<h3 id="kqmlU">方法的修饰符？区别？</h3>
public Protected private 

<p>abstract static native final sync<br>区别是 权限问题</p>
<h3 id="vJ5PX">String相关问题：</h3>
<h4 id="kZuIg">**String str=“i“与 String str=new String(“i”)一样吗？**</h4>
不一样，区别在于 内存分配方式不一样；第一种方式，Java 虚拟机会将其分配到常量池中；第二种则会被分到堆内存中。

<p>因为：<br>str&#x3D;“i“ 会把i值存在常量池，地址赋给str1。假设再写一个String str2&#x3D;“i”，则会把i的地址赋给str2，但是i对象不会重新创建，他们引用的是同一个地址值，共享同一个i内存<br>String str&#x3D;new String(“i”)；会创建一个新的i对象，然后将新对象的地址值赋给str3。虽然str3和str1的值相同但是地址值不同。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2025/png/42573811/1735979115349-58a155ab-401d-4141-8c0b-5bb700dec0eb.png"></p>
<h4 id="ci9p6">**String、StringBuffer、StringBuilder之间的区别**</h4>
String 是 被声明成为 final class，所有属性也都是 final 的。是不可变的，也由于它**的不可变**性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。**用到的最多**

<p>StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。</p>
<p>StringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它<strong>去掉了线程安全的部分（方法加了 sync 关键字）</strong>，有效减小了开销，是绝大部分情况下<strong>进行字符串拼接的首选</strong>。<strong>大量字符串拼接时常用的。</strong></p>
<hr>
<p><strong><font style="color:rgb(51,51,51);">请总结⼀下使⽤场景 </font></strong></p>
<p><strong><font style="color:rgb(51,51,51);">String</font></strong><font style="color:rgb(51,51,51);">：适⽤于字符串内容不会改变的场景，⽐如说作为</font><font style="color:rgb(51,51,51);"> HashMap </font><font style="color:rgb(51,51,51);">的</font><font style="color:rgb(51,51,51);"> key</font><font style="color:rgb(51,51,51);">。 </font></p>
<p><strong><font style="color:rgb(51,51,51);">StringBuilder</font></strong><font style="color:rgb(51,51,51);">：适⽤于单线程环境下需要频繁修改字符串内容的场景，⽐如在循环中拼接或修改字符串，是String 的完美替代品。 </font></p>
<p><strong><font style="color:rgb(51,51,51);">StringBuffer</font></strong><font style="color:rgb(51,51,51);">：现在已经不怎么⽤了，因为⼀般不会在多线程场景下去频繁的修改字符串内容</font></p>
<p><font style="color:rgb(51,51,51);"></font></p>
<h4 id="zufTB">**String str = new String("abc")过程**</h4>
使用构造函数构建String对象，如String str = new String("abc")：通过new关键字创建字符串对象，会**先检查字符串常量池中是否有**相同的字符串，如果**有 则拷贝一份放到堆中**，然后**返回堆中地址**；如果没有 就先在字符串常量池中**创建"abc"这个字符串**，而后再复制一份放到堆中 并把堆地址返回给str

<h4 id="kJf5D">**String str = "abc"过程**</h4>
使用字符串字面值创建String对象，如String str = "abc"：java中有个字符串常量池，当创建一个字面量字符串时，JVM首**先检查字符串常量池中是否已经存在该字符串**，如果存在 则直接**返回字符串对象的引用**，否则就**创建一个新的字符串对象并放入字符串常量池中，**最终将该**对象的引用赋值给变量str**。引用str指向常量池中字符串"abc"的地址，是在常量池中拿值；字符串常量池中不会存储相同内容的字符串

<p>所以String str1&#x3D;”abc”和String str2&#x3D;new String(“abc”)区别就是：<strong>创建的对象数量不同</strong></p>
<h3 id="fGUIj">List和数组直接如何互相转换?</h3>
<h4 id="YqxSi">list-> 数组</h4>
1. for 循环
2. toArray()方法

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要转换的list集合</span></span><br><span class="line">List&lt;String&gt; testList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;add(<span class="string">&quot;aa&quot;</span>);add(<span class="string">&quot;bb&quot;</span>);add(<span class="string">&quot;cc&quot;</span>);&#125;&#125;;</span><br><span class="line"><span class="comment">//使用toArray(T[] a)方法</span></span><br><span class="line">String[] array2 = testList.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[testList.size()]);</span><br></pre></td></tr></table></figure>

<h4 id="QUPyb">数组 -> list</h4>
1. for循环
2. asList()

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(arrays));</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(arrays);  <span class="comment">// 不推荐使用</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>stream方法</li>
</ol>
<h3 id="ZH7bX">翻转字符串</h3>
StringBuilder 自带的 revers 方法  
tocharArray 方法 + for 循环倒序输出  
栈

<h3 id="tksP1">JAVA 反射</h3>
Java的 反射机制 是在运行状态中，对于任意一个类，都能够 知道这个类的所有属性和方法 ；对于任意一个对象，都能够 调用它的任意一个方法和属性 ；这种 动态获取的信息以及动态调用对象的方法的功能 称为 Java 语言的反射机制。

<p><strong><font style="color:rgb(51,51,51);">反射允许 Java 在运⾏时检查和操作类的⽅法和字段。通过反射，可以动态地获取类的字段、⽅法、构造⽅法等信息，并在运⾏时调⽤⽅法或访问字段。</font></strong></p>
<p><font style="color:rgb(51,51,51);"></font></p>
<h4 id="escY3">反射的关键实现方法有以下几个：</h4>
1. 得到类：Class.forName("类名")
2. 得到所有字段：getDeclaredFields()
3. 得到所有方法：getDeclaredMethods()
4. 得到构造方法：getDeclaredConstructor()
5. 得到实例：newInstance()
6. 调用方法：invoke()



<h4 id="bBVBt">实例化方法（五种）：</h4>
1、用new语句创建对象  
2、使用Class类的newInstance方法  
3、使用Constructor类的newInstance方法（运用反射手段）  
4、调用对象的clone()方法  
5、使用反序列化

<p>其中 反射创建</p>
<ul>
<li>用 <code>Class</code> 对象的 <code>newInstance</code> 方法。</li>
<li>用 <code>Constructor</code> 对象的 <code>newInstance</code> 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewInstanceDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; c1 = StringBuilder.class;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> (StringBuilder) c1.newInstance();  <span class="comment">// `newInstance`</span></span><br><span class="line">        sb.append(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">        Class&lt;?&gt; c2 = String.class;</span><br><span class="line">        <span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c2.getConstructor(String.class); <span class="comment">// `Constructor`对象方法</span></span><br><span class="line">        <span class="comment">//根据构造器创建实例</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> (String) constructor.newInstance(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="iIweg">引用类型有哪些？有什么区别？</h3>
引用类型主要分为强软弱虚四种：

<p>**强引用 **指的就是代码中普遍存在的赋值方式，<font style="color:rgb(51,51,51);">使⽤ new 关键字赋值的引⽤就是强引⽤</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str 就是⼀个强引⽤ </span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;沉默王⼆&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(51,51,51);">只要强引⽤关联着对象，垃圾收集器就不会回收这部分对象，即使内存不⾜。</font></p>
<p><font style="color:rgb(51,51,51);"></font></p>
<p><strong>软引用</strong> <font style="color:rgb(51,51,51);">通过 </font><strong><font style="color:rgb(51,51,51);">SoftReference</font></strong><font style="color:rgb(51,51,51);"> 类实现。软引⽤的对象在内存不⾜时会被回收。</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// softRef 就是⼀个软引⽤</span></span><br><span class="line">SoftReference&lt;String&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;沉默王⼆&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>指的是那些有用但是不是必须要的对象。系统在发生内存溢出前会对这类引用的对象进行回收。</p>
<p>弱引用可以用 **WeakReference **来描述，他的强度比软引用更低一点，弱引用的对象下一次GC的时候一定会被回收，而不管内存是否足够。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line">        <span class="comment">//节点类</span></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="comment">//key赋值</span></span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        <span class="comment">//value赋值</span></span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚引用也被称作幻影引用，是最弱的引用关系，可以用 <strong>PhantomReference</strong> 来描述，他必须和ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。</p>
<h3 id="Grrc0">深拷贝和浅拷贝</h3>
**浅拷贝**是指我们拷贝出来的对象内部的引用类型变量和原来**对象内部引用类型变量是同一引用**（指向同一对象）， 但是我们拷贝出来的对象和新对象不是同一对象;  
新（拷贝产生）、旧（元对象）对象不同，但是内部如果有引用类型的变量，新、旧对象引用的都是同一引用  
**深拷贝**: 全部拷贝原对象的内容，包括内存的引用类型也进行拷贝



<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2025/png/42573811/1735978408986-70d87a41-71f7-452f-91d0-b72e97fcffc8.png"></p>
<p><font style="color:rgb(51,51,51);">浅拷⻉会创建⼀个新对象，但这个新对象的属性（字段）和原对象的属性完全相同。如果属性是基本数据类型，拷⻉的是基本数据类型的值；如果属性是引⽤类型，拷⻉的是引⽤地址，因此新旧对象共享同⼀个引⽤对象。</font></p>
<h4 id="RXixq">clone 方法默认是浅拷贝</h4>
clone 方法**默认是浅拷贝**的，即返回一个新的对象，但是新对象里的引用类型变量地址指向的还是原对象内引用类型地址  
浅拷贝通常通过 `Object`** 类中的 **`clone()`** 方法** 实现。默认的 `clone()` 方法会进行浅拷贝。

<h4 id="pZ7ga">clone()方法的深拷贝</h4>
需要手动覆盖 `clone()` 方法，确保对引用类型进行递归拷贝。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    Address address;  <span class="comment">// 引用类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖 clone() 方法实现深拷贝</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// 首先浅拷贝基本字段</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">clonedPerson</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">// 递归拷贝引用类型的字段</span></span><br><span class="line">        clonedPerson.address = (Address) <span class="built_in">this</span>.address.clone();</span><br><span class="line">        <span class="keyword">return</span> clonedPerson;  <span class="comment">// 返回完全独立的副本</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();  <span class="comment">// Address 的浅拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BWYWI">JDK 17的主要新特性</h3>
+ 模式匹配：引入了模式匹配特性，简化了代码编写。
+ 密封类：增强了类型安全，限制了继承范围。
+ 异常处理：改进了异常处理机制，使得错误处理更加灵活。
+ I/O特性：引入了新的文件系统API和管道API，增强了I/O操作。
+ 强封装：限制了内部API的可见性，提高了模块化程度。
+ 外部函数和内存API：提升了与本地代码的互操作性，增强了性能。
+ 垃圾收集器改进：对G1和ZGC垃圾收集器进行了优化

<h3 id="lrD9P">JDK 8 新特性</h3>


<h4 id="L0jbi">Future是什么</h4>
用于异步结果的获取;  
Future 代表的是异步执行的结果，意思是当异步执行结束之后，返回的结果将会保存在 Future 中。  
callabel 比 runnable 多了个返回值; 并且`Callable`接口是一个泛型接口，可以**返回指定类型的结果。**  
之后 `ExecutorService.submit()`方法，可以看到，它返回了一个`Future`类型，一个`Future`类型的实例代表一个未来能获取结果的对象:

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line"><span class="comment">// 提交任务并获得Future:</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure>

<p>当我们提交一个<code>Callable</code>任务后，我们会同时获得一个<code>Future</code>对象，然后，我们在主线程某个时刻调用<code>Future</code>对象的<code>get()</code>方法，就可以获得异步执行的结果。在调用<code>get()</code>时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么<code>get()</code>会阻塞，直到任务完成后才返回结果。</p>
<p><strong>Callable + ExecutorService.submit() -&gt; Future</strong></p>
<h4 id="d4mBK">Java8的CompletableFuture</h4>
<h5 id="YKeUE">问题:</h5>
使用`Future`获得异步执行结果时，要么调用阻塞方法`get()`，要么轮询看`isDone()`是否为`true`，这两种方法都不是很好，因为主线程也会被迫等待。

<p>java8新引入的工具, 是对Future的扩展和增强。提供了更细致的操控;组织不同任务的运行顺序、规则以及方式(CountDownLatch也可以)</p>
<p><code>CompletableFuture</code>可以指定异步处理流程：</p>
<ul>
<li><code>thenAccept()</code>处理正常结果；</li>
<li><code>exceptional()</code>处理异常结果；</li>
<li><code>thenApplyAsync()</code>用于串行化另一个<code>CompletableFuture</code>；</li>
<li><code>anyOf()</code>和<code>allOf()</code>用于并行化多个<code>CompletableFuture</code>。</li>
</ul>
<h4 id="b5lKy">如何使用CompletableFuture实现调用一个接口，过一段时间没完成就超时返回，中断执行任务的线程这个功能？</h4>
java8中没有 CompletableFuture 并没有 timeout 机制; 可以在在 get 的时候指定 timeout  
java9 引入了 `orTimeout` 和 `completeOnTimeOut` 两个方法支持 异步 timeout 机制

<p><code>orTimeout</code>: 在指定的超时时间过去后，使用TimeoutException完成CompletableFuture。<br><code>completeOnTimeOut</code>:在CompletableFuture管道超时的情况下返回一个指定的默认值。</p>
<h4 id="VZvMb">使用例子</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrTimeoutMethodTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">      CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> a + b;</span><br><span class="line">      &#125;)</span><br><span class="line">      .orTimeout(<span class="number">4</span>, TimeUnit.SECONDS)</span><br><span class="line">      .whenComplete((result, exception) -&gt; &#123;</span><br><span class="line">         System.out.println(result);</span><br><span class="line">         <span class="keyword">if</span>(exception != <span class="literal">null</span>)</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">      &#125;);</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompleteOnTimeOutMethodTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">      CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> a + b;</span><br><span class="line">      &#125;)</span><br><span class="line">      .completeOnTimeout(<span class="number">0</span>, <span class="number">4</span>, TimeUnit.SECONDS)</span><br><span class="line">      .thenAccept(result -&gt; System.out.println(result));</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Zj5gx">java异常处理</h3>
![](https://cdn.nlark.com/yuque/0/2024/png/42573811/1734607922116-685f8f57-ade4-456c-8538-80edf49d02f0.png)

<h4 id="JqTYx">Exception、Error 和 Throwable</h4>
**Throwable** 是异常和错误的超类，有两个**子类 Exception 和 Error**

<p><strong>Exception（异常）</strong>：<br>J<strong>ava异常分为两种类型</strong>：（<strong>编译时异常、运行时异常</strong>）</p>
<ol>
<li><strong>编译时</strong>异常：是指在编译时强制检查的异常，必须在代码中显式地处理或声明抛出。例如，IOException和SQLException就是已检查异常。</li>
</ol>
<p><font style="color:rgb(51,51,51);">如果⽅法可能抛出某种编译时异常，但没有捕获它（try-catch）或没有在⽅法声明中⽤ throws ⼦句声明它，那么编译将不会通过。例如：IOException、SQLException 等。</font></p>
<ol start="2">
<li><strong>运行时</strong>异常：是指在编译时不强制检查的异常，不需要在代码中显式地处理或声明抛出。<font style="color:rgb(51,51,51);">这类异常在运⾏时抛出，它们都是 RuntimeException 的⼦类。对于运⾏时异常，Java 编译器不要求必须处理它们（即不需要捕获也不需要声明抛出）</font></li>
</ol>
<p>常见的未检查异常包括NullPointerException、ArrayIndexOutOfBoundsException和				       ArithmeticException等。</p>
<p><strong>Error（错误）：</strong><br>Error也是 Java 中的一个类，表示通常超出程序控制范围的严重问题。错误通常是由外部因素或JVM或系统的基本问题引起的。错误的例子包括 OutOfMemoryError 和 StackOverflowError。与异常不同，错误通常不应该被程序捕获和处理，因为它们表示严重的问题，可能是无法恢复的。</p>
<h5 id="XOD37">常见 Exception、 Error</h5>
**Exception：**  
🌴 NullPointerException（空指针异常）：当尝试使用空引用调用对象的方法或访问对象的字段时抛出。  
🌴 ArrayIndexOutOfBoundsException（数组越界异常）：当尝试访问数组中不存在的索引时抛出。  
🌴 IllegalArgumentException（非法参数异常）：当传递给方法的参数不满足方法的要求时抛出。  
🌴 IllegalStateException（非法状态异常）：当对象的状态不符合方法调用的前提条件时抛出。  
🌴 IOException（输入输出异常）：在处理输入输出操作时发生错误时抛出。  
🌴 ClassNotFoundException（类未找到异常）：当尝试加载不存在的类时抛出。  
🌴 InterruptedException（中断异常）：在线程等待、休眠或阻塞的过程中被中断时抛出。  
🌴 SQLException（SQL异常）：在访问数据库时发生错误时抛出。  
🌴 FileNotFoundException（文件未找到异常）：当尝试访问不存在的文件时抛出。  
🌴 ArithmeticException（算术异常）：在算术操作中出现错误时抛出，例如除以零。

<p><strong>Error：</strong><br>🌴 OutOfMemoryError（内存溢出错误）：当Java虚拟机无法为对象分配足够的内存空间时抛出。<br>🌴 StackOverflowError（栈溢出错误）：当方法调用的调用栈超过其限制时抛出，通常是由于递归调用导致的。<br>🌴 NoClassDefFoundError（类未定义错误）：当Java虚拟机无法找到类的定义时抛出，通常是由于类路径配置错误或类文件缺失引起的。<br>🌴 LinkageError（链接错误）：当Java虚拟机在类加载过程中遇到链接错误时抛出，例如类与其依赖的类不兼容。<br>🌴 AssertionError（断言错误）：当断言语句失败时抛出，通常用于在代码中检查预期的条件是否满足。<br>🌴 VirtualMachineError（虚拟机错误）：表示Java虚拟机内部发生了错误，例如栈溢出、垃圾回收失败等。<br>🌴 InternalError（内部错误）：表示Java虚拟机内部发生了严重的错误，无法恢复。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/42573811/1734608227487-e7150ca7-3ea0-40ba-8b26-e8de4e3e38dc.png"></p>
<h3 id="EeU3H">try-catch-final</h3>
<h5 id="fxdT5">try-catch-final哪些可以省略</h5>
以下三种情况都是可以的：  
try-catch  
try-finally  
try-catch-finally  
可以省略catch或者finally，catch和finally不可以同时省略。

<h4 id="MWN9L">finally是必须的吗，什么时候加上</h4>
finally并不是必须的，finally里一般拿来做一些善后清理工作  
try块里出现错误的话，会立即跳出try块，找到匹配的错误，执行catch块里的语句  
此时，可能在try块里打开的文件没关闭，连接的网络没断开，对这些浪费的内存就不能及时释放回收。  
如果有finally块的话，不管有没有出错，都会执行finally块里的内容。

<h4 id="e5WfZ">如果 catch 中 return 了，finally 还会执行吗？</h4>
**会**

<ol>
<li>finally的作用就是，无论出现什么状况，finally里的代码一定会被执行。</li>
<li>如果在catch中return了，也会在return之前，先执行finally代码块。</li>
<li>而且如果finally代码块中含有return语句，会覆盖其他地方的return。</li>
<li>对于<strong>基本数据类型</strong>的数据，在finally块中改变return的值对返回值<strong>没有影响</strong>，而对<strong>引用数据类型的数据会有影响</strong>。</li>
</ol>
<p>注：<br>finally也不是一定会被执行。</p>
<h4 id="BlRx3">什么情形下，finally代码块不会执行？</h4>
1. 没有进入try代码块；
2. System.exit()强制退出程序；
3. 守护线程被终止；



<h3 id="T6uK6">初始化Bean的方法</h3>
1. spring加载配置 Bean
2. 实现 initializingBean 接口的afterPropertiesSet()方法（InitializingBean 为实现该接口**的bean提供默认的初始化方法**）
3. postProcessAfterInitialization()方法里实现自定义Bean（BeanPostProcessor 为每个**bean实例化时提供个性化的修改，做些包装等**）



<h3 id="FbibG">动态代理怎么实现？</h3>
<h4 id="zhMjz">JDK 动态代理的实现</h4>
<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">通过JDK提供的一个</font>`Proxy.newProxyInstance()`<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">创建代理对象；</font>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理的行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Executor</span> <span class="keyword">implements</span> <span class="title class_">ExecutorInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeLogHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimeLogHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start：&#123;&#125;&quot;</span>, System.nanoTime());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        log.info(<span class="string">&quot;end：&#123;&#125;&quot;</span>, System.nanoTime());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成代理类</span></span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> (Executor) Proxy.newProxyInstance(</span><br><span class="line">        Executor.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Executor.class&#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TimeLogHandler</span>);</span><br></pre></td></tr></table></figure>

<h4 id="RgfTU">Spring 里的动态代理实现</h4>
提供的 ProxyFactory 有一个 getProxy() 方法，实现ProxyFactory接口重写 getProxy() 方法；

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">ProxyFactory</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(ReferenceWrapper&lt;T&gt; referenceWrapper)</span> <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(referenceWrapper.getAimClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;referenceWrapper.getAimClass()&#125;, <span class="keyword">new</span> <span class="title class_">JDKClientInvocationHandler</span>(referenceWrapper));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy.newProxyInstance是JDK静态方法，参数三个：</span></span><br><span class="line"><span class="comment">// ClassLoader loader,  </span></span><br><span class="line"><span class="comment">// Class&lt;?&gt;[] interfaces,  </span></span><br><span class="line"><span class="comment">// InvocationHandler h</span></span><br><span class="line"></span><br><span class="line">其中，<span class="keyword">new</span> <span class="title class_">JDKClientInvocationHandler</span>(referenceWrapper)的JDKClientInvocationHandler类</span><br><span class="line">实现了InvocationHandler类，重写invoke()方法，在该方法里做代理相关的处理。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcReference</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> ProxyFactory proxyFactory;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcReference</span><span class="params">(ProxyFactory proxyFactory)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.proxyFactory = proxyFactory;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 根据接口类型获取代理对象  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(ReferenceWrapper&lt;T&gt; referenceWrapper)</span> <span class="keyword">throws</span> Throwable&#123;  </span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getProxy(referenceWrapper);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">根据类型自动获取一个对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="P4c6S">原理</h4>
使用流程

<ol>
<li><strong>创建 <strong><code>InvocationHandler</code></strong> 实现</strong>：定义一个 <code>InvocationHandler</code> 的实现，这个实现中的 <code>invoke</code> 方法可以包含自定义逻辑。</li>
<li><strong>创建代理对象</strong>：使用 <code>Proxy.newProxyInstance</code> 方法，传入目标对象的类加载器、需要代理的接口数组以及 <code>InvocationHandler</code> 的实现，来创建一个实现了指定接口的代理对象。</li>
</ol>
<p><code>InvocationHandler</code> 是动态代理的核心接口之一，<strong>当我们使用动态代理模式创建代理对象时，任何对代理对象的方法调用都会被转发到一个实现了 <strong><code>InvocationHandler</code></strong> 接口的实例的 <strong><code>invoke</code></strong> 方法上</strong>。</p>
<p>我们经常看到<code>InvocationHandler</code> 动态代理的匿名内部类，这会在代理对象的相应方法被调用时执行。具体地说，<strong>每当对代理对象执行方法调用时，调用的方法不会直接执行，而是转发到实现了</strong><code>InvocationHandler</code>** 的 <strong><code>invoke</code></strong> 方法上。在这个 <strong><code>invoke</code></strong> 方法内部，我们可以定义拦截逻辑、调用原始对象的方法、修改返回值等操作**。</p>
<h4 id="FYPz9">静态代理</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Marry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toMarry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态代理 ——&gt; 目标对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">You</span> <span class="keyword">implements</span>  <span class="title class_">Marry</span> &#123;</span><br><span class="line">    <span class="comment">// 实现行为</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toMarry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要结婚了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态代理 ——&gt; 代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarryCompanyProxy</span> <span class="keyword">implements</span> <span class="title class_">Marry</span> &#123;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Marry marry;</span><br><span class="line">    <span class="comment">// 通过构造器将目标对象传入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MarryCompanyProxy</span><span class="params">(Marry marry)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.marry = marry;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 实现行为</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toMarry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 增强行为</span></span><br><span class="line">        before();</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 执行目标对象中的方法</span></span><br><span class="line">        marry.toMarry();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 增强行为</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增强行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新婚快乐，早生贵子！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增强行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;场地正在布置中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="type">You</span> <span class="variable">you</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">You</span>();</span><br><span class="line"><span class="comment">// 构造代理角色同时传入真实角色</span></span><br><span class="line"><span class="type">MarryCompanyProxy</span> <span class="variable">marryCompanyProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MarryCompanyProxy</span>(you);</span><br><span class="line"><span class="comment">// 通过代理对象调用目标对象中的方法</span></span><br><span class="line">marryCompanyProxy.toMarry();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="DGgiO">零拷贝</h3>
零拷贝技术实现的方式通常有 2 种：

<ul>
<li>mmap + write</li>
<li>sendfile</li>
</ul>
<p>主要是为了减少 <strong>内核缓冲区的数据拷贝到用户的缓冲区</strong> 这样的切换用户&#x2F;内核态<br><code>mmap()</code> 直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，减少一次切换。</p>
<p>Kafka 这个开源项目，就利用了「零拷贝」技术，从而大幅提升了 I&#x2F;O 的吞吐率，这也是 Kafka 在处理海量数据为什么这么快的原因之一。<br>如果你追溯 Kafka 文件传输的代码，你会发现，最终它调用了 Java NIO 库里的 <code>transferTo</code>方法</p>
<h3 id="jX0KR">项目有遇到过循环依赖吗？如何解决</h3>
主要就是 重构代码；  
平移 A和B互相依赖，那么可以将B依赖A的那部分代码，移动到工程B中，这样一来，B就不需要继续依赖A，只要A依赖B就可以了，从而消除循环依赖  
下移，比如A和B互相依赖，同时它们都依赖C，那么可以将B和A相互依赖的那部分代码，移动到工程C里，这样一来，A和B相互之间都不依赖，只继续依赖C，也可以消除循环依赖



<h3 id="XjErh">java读文件</h3>
1.Mmap映射文件到内存，之后写入，刷盘  
2.java.io.FileInputStream和java.io.FileOutputStream 方式

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;abc.txt&quot;</span>);</span><br><span class="line">         <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">         <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fis.read(data);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;abc.txt&quot;</span>,<span class="literal">true</span>); </span><br><span class="line">​</span><br><span class="line">        fos.write(<span class="string">&quot;???&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>


<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>License</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    
    <section id="share">
      <div class="header"><span>Share</span></div>
      <div class="body">
        <div class="link"><input class="copy-area" readonly="true" id="copy-link" value="http://example.com/posts/0.html" /></div>
        <div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot;)"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg" /></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=http://example.com/posts/0.html&title= - Yes的知识星球&summary=字节（Byte）和位（Bit）
1 GB = 1024 MB，GB：千兆  
1 MB = 1024 KB，MB：兆  
1 KB = 1024 B，KB：千字节，B 是 Byte 的缩写，即字节

基本数据类型	类型	字节数	位数	..."><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg" /></a><a class="social share-item email" href="mailto:?subject= - Yes的知识星球&amp;body=http://example.com/posts/0.html"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg" /></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;Copied!&quot;)"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg" /></a></div>
        
        <div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0">
          <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=http://example.com/posts/0.html"/>
        </div>
        
      </div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"></div><div class="item" id="next"><div class="note">Older</div><a href="/posts/undefined.html">test1</a></div></section></div>

<div class="related-wrap" id="related-posts">
    <section class='header'>
      <div class='title cap theme'>您可能感兴趣的文章</div>
    </section>
    <section class='body'>
    <div class="related-posts"><a class="item" href="\posts\16107.html" title="Hello World"><span class="title">Hello World</span></a></div></section></div>




<footer class="page-footer footnote"><hr><div class="text"><center>
<a href="" target=""><
</br>
</br>
<!--不蒜子计数器-->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!--添加一个访问量-->
<span>
                本"<span style="color: rgb(13, 109, 252); font-weight: bold;">页面</ a></span>"访问 <span id="busuanzi_value_page_pv" style="color: rgb(13, 109, 252); font-weight: bold;"></span> 次 | 👀总访问 <span id="busuanzi_value_site_pv" style="color: rgb(13, 109, 252); font-weight: bold;"></span>                次 | 🥷总访客 <span id="busuanzi_value_site_uv" style="color: rgb(13, 109, 252); font-weight: bold;"></span> 人
            </span>
</br>
</br>
<script type="text/javascript">
function show_runtime() {
    window.setTimeout("show_runtime()", 1000);
    X = new Date("1/26/2025 20:00:00");
    Y = new Date();
    T = (Y.getTime() - X.getTime());
    M = 24 * 60 * 60 * 1000;
    a = T / M;
    A = Math.floor(a);
    b = (a - A) * 24;
    B = Math.floor(b);
    c = (b - B) * 60;
    C = Math.floor((b - B) * 60);
    D = Math.floor((c - C) * 60);
    runtime_span.innerHTML = "⏱️本站已运行 " + A + "天" + B + "小时" + C + "分" + D + "秒"
}
show_runtime();
</script>
<span id="runtime_span"></span>
</center>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">On This Page</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#VDtbV"><span class="toc-text">字节（Byte）和位（Bit）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rAglo"><span class="toc-text">封装、继承多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Q2qrV"><span class="toc-text">多态机制？Java语言是如何实现多态的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IGWIF"><span class="toc-text">接口和抽象类有什么共同点和区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jLKie"><span class="toc-text">八种数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#yqMUe"><span class="toc-text">拆箱装箱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iWeBu"><span class="toc-text">基本数据类型和包装类的用处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zKJHw"><span class="toc-text">静态方法为什么不能调用非静态成员？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kqmlU"><span class="toc-text">方法的修饰符？区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vJ5PX"><span class="toc-text">String相关问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kZuIg"><span class="toc-text">**String str&#x3D;“i“与 String str&#x3D;new String(“i”)一样吗？**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ci9p6"><span class="toc-text">**String、StringBuffer、StringBuilder之间的区别**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zufTB"><span class="toc-text">**String str &#x3D; new String(&quot;abc&quot;)过程**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kJf5D"><span class="toc-text">**String str &#x3D; &quot;abc&quot;过程**</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fGUIj"><span class="toc-text">List和数组直接如何互相转换?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#YqxSi"><span class="toc-text">list-&gt; 数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QUPyb"><span class="toc-text">数组 -&gt; list</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZH7bX"><span class="toc-text">翻转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tksP1"><span class="toc-text">JAVA 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#escY3"><span class="toc-text">反射的关键实现方法有以下几个：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bBVBt"><span class="toc-text">实例化方法（五种）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iIweg"><span class="toc-text">引用类型有哪些？有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Grrc0"><span class="toc-text">深拷贝和浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RXixq"><span class="toc-text">clone 方法默认是浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pZ7ga"><span class="toc-text">clone()方法的深拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BWYWI"><span class="toc-text">JDK 17的主要新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lrD9P"><span class="toc-text">JDK 8 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#L0jbi"><span class="toc-text">Future是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d4mBK"><span class="toc-text">Java8的CompletableFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#YKeUE"><span class="toc-text">问题:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b5lKy"><span class="toc-text">如何使用CompletableFuture实现调用一个接口，过一段时间没完成就超时返回，中断执行任务的线程这个功能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VZvMb"><span class="toc-text">使用例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zj5gx"><span class="toc-text">java异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JqTYx"><span class="toc-text">Exception、Error 和 Throwable</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#XOD37"><span class="toc-text">常见 Exception、 Error</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EeU3H"><span class="toc-text">try-catch-final</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fxdT5"><span class="toc-text">try-catch-final哪些可以省略</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MWN9L"><span class="toc-text">finally是必须的吗，什么时候加上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e5WfZ"><span class="toc-text">如果 catch 中 return 了，finally 还会执行吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BlRx3"><span class="toc-text">什么情形下，finally代码块不会执行？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#T6uK6"><span class="toc-text">初始化Bean的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FbibG"><span class="toc-text">动态代理怎么实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#zhMjz"><span class="toc-text">JDK 动态代理的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RgfTU"><span class="toc-text">Spring 里的动态代理实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P4c6S"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FYPz9"><span class="toc-text">静态代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DGgiO"><span class="toc-text">零拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jX0KR"><span class="toc-text">项目有遇到过循环依赖吗？如何解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XjErh"><span class="toc-text">java读文件</span></a></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>Scroll to Top</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `Just`,
      min: `minutes ago`,
      hour: `hours ago`,
      day: `days ago`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.29.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)

    const messages = {
      light: `Switched to Light Mode`,
      dark: `Switched to Dark Mode`,
      auto: `Switched to Auto Mode`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    }
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
